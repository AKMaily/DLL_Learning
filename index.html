<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DLL Learning</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css"
        integrity="sha512-XXXXXX" crossorigin="anonymous" />
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <div class="navbar" id="navbar">
        <ul class="navbar-links">
            <li>
                <a href="#grundlagen">Grundlagen</a>
                <ul class="sub-links">
                    <li><a href="#grundlagen-1">Unterschied zwischen statischen und dynamischen Bibliotheken</a></li>
                    <li><a href="#grundlagen-2">Verwendungszweck von DLLs in der Softwareentwicklung</a></li>
                </ul>
            </li>
            <li>
                <a href="#entwicklung">DLL-Entwicklung</a>
                <ul class="sub-links">
                    <li><a href="#entwicklung-1">Programmiersprachen für DLL-Entwicklung (z.B. C++, C#)</a></li>
                    <li><a href="#entwicklung-2">Erstellung einfacher DLLs</a></li>
                </ul>
            </li>
            <li>
                <a href="#integration">Integration mit Hardware</a>
                <ul class="sub-links">
                    <li><a href="#integration-1">Kommunikationsprotokolle für Hardwareintegration</a></li>
                    <li><a href="#integration-2">Testumgebungen für DLL und Hardwaregeräte</a></li>
                </ul>
            </li>
            <li>
                <a href="#sicherheit">Sicherheit und Stabilität</a>
                <ul class="sub-links">
                    <li><a href="#sicherheit-1">Fehlererkennung und Fehlerbehandlung in DLLs</a></li>
                    <li><a href="#sicherheit-2">Optimierung für Stabilität und Performance</a></li>
                </ul>
            </li>
            <li>
                <a href="#dokumentation">Dokumentation und Wartung</a>
                <ul class="sub-links">
                    <li><a href="#dokumentation-1">Erstellung von API-Dokumentationen</a></li>
                    <li><a href="#dokumentation-2">Planung von Wartungsintervallen</a></li>
                </ul>
            </li>
        </ul>
    </div>

    <!-- Infobox -->
    <div class="infobox">
        <h1>Warum diese Webseite existiert:</h1>
        <p>Diese Webseite dient dazu, das Verständnis und die Fähigkeiten zur Entwicklung und Integration von DLLs
            (Dynamic Link Libraries) zu fördern.</p>
    </div>

    <!-- Checklist -->
    <div class="checklist">
        <h2>Checkliste zum Erlernen von DLLs</h2>
        <ul id="dll-checklist">
            <li><input type="checkbox" id="chk-grundlagen"><label for="chk-grundlagen"><a href="#grundlagen">Grundlagen
                        zu DLLs verstehen</a></label></li>
            <ul class="subchecklist">
                <li>Unterschied zwischen statischen und dynamischen Bibliotheken</li>
                <li>Verwendungszweck von DLLs in der Softwareentwicklung</li>
            </ul>
            <li><input type="checkbox" id="chk-entwicklung"><label for="chk-entwicklung"><a
                        href="#entwicklung">DLL-Entwicklung</a></label></li>
            <ul class="subchecklist">
                <li>Programmiersprachen für DLL-Entwicklung (z.B. C++, C#)</li>
                <li>Erstellung einfacher DLLs</li>
            </ul>
            <li><input type="checkbox" id="chk-integration"><label for="chk-integration"><a
                        href="#integration">Integration mit Hardware</a></label></li>
            <ul class="subchecklist">
                <li>Kommunikationsprotokolle für Hardwareintegration</li>
                <li>Testumgebungen für DLL und Hardwaregeräte</li>
            </ul>
            <li><input type="checkbox" id="chk-sicherheit"><label for="chk-sicherheit"><a href="#sicherheit">Sicherheit
                        und Stabilität</a></label></li>
            <ul class="subchecklist">
                <li>Fehlererkennung und Fehlerbehandlung in DLLs</li>
                <li>Optimierung für Stabilität und Performance</li>
            </ul>
            <li><input type="checkbox" id="chk-dokumentation"><label for="chk-dokumentation"><a
                        href="#dokumentation">Dokumentation und Wartung</a></label></li>
            <ul class="subchecklist">
                <li>Erstellung von API-Dokumentationen</li>
                <li>Planung von Wartungsintervallen</li>
            </ul>
        </ul>
    </div>

    <!-- Section: Grundlagen zu DLLs verstehen -->
    <div id="grundlagen" class="section">
        <div class="infobox">
            <h3>Grundlagen zu DLLs verstehen</h3>
            <p>Lerne die Grundlagen darüber, was DLLs sind und wie sie in der Softwareentwicklung verwendet werden.</p>
        </div>
        <div id="grundlagen-1">
            <h2>Unterschiede zwischen statischen und dynamischen Bibliotheken</h2>

            <h3>Statische Bibliotheken:</h3>
            <p>Statische Bibliotheken, auch bekannt als "statisch gelinkte Bibliotheken", bestehen aus vorkompiliertem
                Code, der während der Kompilierung in das ausführbare Programm eingebunden wird.</p>

            <ul>
                <li><strong>Kompilierung:</strong> Der Code wird während der Kompilierung des Programms in das
                    ausführbare Programm eingebunden.</li>
                <li><strong>Dateiendung:</strong> Typischerweise .lib (unter Windows) oder .a (unter Unix/Linux).</li>
                <li><strong>Vorteile:</strong>
                    <ul>
                        <li>Schnellere Ausführung: Kein Laden zur Laufzeit führt normalerweise zu schnelleren
                            Ausführungszeiten.</li>
                        <li>Einfache Verteilung: Das gesamte Programm und alle benötigten Bibliotheken sind in einer
                            ausführbaren Datei enthalten.</li>
                        <li>Unabhängigkeit: Das Programm ist unabhängig von externen Bibliotheken auf dem System.</li>
                    </ul>
                </li>
                <li><strong>Nachteile:</strong>
                    <ul>
                        <li>Größere Dateigröße: Der gesamte Bibliothekscode wird in das Programm eingebunden.</li>
                        <li>Schwierigeres Updatemanagement: Änderungen erfordern eine erneute Kompilierung des gesamten
                            Programms.</li>
                    </ul>
                </li>
            </ul>
        </div>
        <div class="codebox">
            <h3> Beispiel : </h3>
            <pre><code>
            #ifndef MATHLIB_H
            #define MATHLIB_H
        
        int add(int a, int b);
        int multiply(int a, int b);
        
        #endif // MATHLIB_H
        </code></pre>
            <button class="copy-button" onclick="copyToClipboard(1)">Kopieren</button>
            <span class="copy-message">Kopiert!</span>

        </div>
        <div class="codebox">
            <pre><code>
            #include "mathlib.h"

            int add(int a, int b) {
                return a + b;
            }
            
            int multiply(int a, int b) {
                return a * b;
            }
        </code></pre>
            <button class="copy-button" onclick="copyToClipboard(1)">Kopieren</button>
            <span class="copy-message">Kopiert!</span>

        </div>
        <div class="codebox">
            <pre><code>
            #include <iostream>
                #include "mathlib.h"
                
                int main() {
                    int x = 5, y = 3;
                    int result_add = add(x, y);
                    int result_multiply = multiply(x, y);
                    
                    std::cout << "Addition: " << result_add << std::endl;
                    std::cout << "Multiplication: " << result_multiply << std::endl;
                    
                    return 0;
                }
        </code></pre>
            <button class="copy-button" onclick="copyToClipboard(1)">Kopieren</button>
            <span class="copy-message">Kopiert!</span>
        </div>

        <h3>Dynamische Bibliotheken:</h3>
        <p>Dynamische Bibliotheken werden zur Laufzeit des Programms geladen und sind separate Dateien, die von mehreren
            Anwendungen gemeinsam genutzt werden können.</p>

        <ul>
            <li><strong>Laden zur Laufzeit:</strong> Der Code wird zur Laufzeit des Programms geladen.</li>
            <li><strong>Dateiendung:</strong> Typischerweise .dll (unter Windows) oder .so (unter Unix/Linux).</li>
            <li><strong>Vorteile:</strong>
                <ul>
                    <li>Geringerer Speicherbedarf: Bibliothek wird nur einmal geladen und von mehreren Programmen
                        genutzt.</li>
                    <li>Einfacheres Updatemanagement: Änderungen erfordern nur die Aktualisierung der Bibliotheksdatei.
                    </li>
                    <li>Flexibilität: Verschiedene Versionen können von verschiedenen Programmen verwendet werden.</li>
                </ul>
            </li>
            <li><strong>Nachteile:</strong>
                <ul>
                    <li>Langsamere Ausführung: Aufgrund des Ladevorgangs zur Laufzeit.</li>
                    <li>Abhängigkeit von externen Bibliotheken: Verfügbarkeit der richtigen Version auf dem Zielsystem.
                    </li>
                </ul>
            </li>
        </ul>
    </div>
    <div class="codebox">
        <h3>Beispielcode für add.c</h3>
        <pre><code>
#include &lt;stdio.h&gt;

int add(int a, int b) {
    return a + b;
}
                    
int multiply(int a, int b) {
    return a * b;
}
    </code></pre>
        <button class="copy-button" onclick="copyToClipboard(0)">Kopieren</button>
        <span class="copy-message">Kopiert!</span>
    </div>

    <div class="codebox">
        <h3>Beispielcode für main.c</h3>
        <pre><code>
        #include <stdio.h>
            #include <dlfcn.h>
            
            typedef int (*MathFunc)(int, int);
            
            int main() {
                // 1. Öffnen der dynamischen Bibliothek (libmath.so) im aktuellen Verzeichnis
                void *handle = dlopen("./libmath.so", RTLD_LAZY);
                if (!handle) {
                    // 2. Fehlerbehandlung, falls das Laden der Bibliothek fehlschlägt
                    fprintf(stderr, "%s\n", dlerror());
                    return 1;
                }
                
                // 3. Laden der Funktionen 'add' und 'multiply' aus der Bibliothek
                MathFunc add_func = (MathFunc)dlsym(handle, "add");
                MathFunc multiply_func = (MathFunc)dlsym(handle, "multiply");
                
                // 4. Definieren von Eingabewerten für die Funktionen
                int x = 5, y = 3;
                
                // 5. Aufrufen der Funktionen mit den definierten Werten
                int result_add = add_func(x, y);
                int result_multiply = multiply_func(x, y);
                
                // 6. Ausgabe der Ergebnisse
                printf("Addition: %d\n", result_add);
                printf("Multiplication: %d\n", result_multiply);
                
                // 7. Schließen der Bibliothek nach der Verwendung
                dlclose(handle);
                
                // 8. Erfolgreicher Programmabschluss
                return 0;
            }
            
    </code></pre>
        <button class="copy-button" onclick="copyToClipboard(1)">Kopieren</button>
        <span class="copy-message">Kopiert!</span>
    </div>
    <div>
        <h2>Definitionen für dlfcn, dlopen, dlsym und dlclose</h2>

        <body>
            <h2>Definitionen und Links zu den Funktionen</h2>

            <h3>dlfcn.h</h3>
            <p>
                Die Header-Datei <code>dlfcn.h</code> definiert die Schnittstellen zum Laden von dynamischen
                Bibliotheken
                in C-Programmen unter Unix- und Unix-ähnlichen Systemen.
                <br>
                <a href="https://man7.org/linux/man-pages/man3/dlfcn.h.3.html" target="_blank">Man-Page für dlfcn.h</a>
            </p>

            <h3>dlopen</h3>
            <p>
                Die Funktion <code>dlopen</code> öffnet eine dynamische Bibliothek zur Laufzeit und gibt einen
                Handhabungszeiger
                auf die Bibliothek zurück, der für weitere Funktionen verwendet wird.
                <br>
                <a href="https://man7.org/linux/man-pages/man3/dlopen.3.html" target="_blank">Man-Page für dlopen</a>
            </p>

            <h3>dlsym</h3>
            <p>
                Kurzfassung: Die Funktion <code>dlsym</code> sucht nach einem Symbol innerhalb einer zuvor mit
                <code>dlopen</code> geöffneten
                Bibliothek und gibt einen Zeiger auf die Funktion oder Variable zurück.
                <br>
            <h2>Beschreibung von <code>dlsym</code></h2>
            <p>
                Die Funktion <code>dlsym</code> ist eine in der Header-Datei <code>dlfcn.h</code> definierte Funktion,
                die in Unix-ähnlichen Betriebssystemen verwendet wird, um Symbole (Funktionen oder Variablen) aus einer
                zuvor mit <code>dlopen</code> geöffneten dynamischen Bibliothek zu suchen und einen Zeiger auf dieses
                Symbol zurückzugeben.
            </p>
            <h3>Genauere Beschreibung von <code>dlsym</code>:</h3>
            <ul>
                <li><strong>Funktionsweise:</strong> Nachdem eine dynamische Bibliothek mit <code>dlopen</code>
                    erfolgreich geöffnet wurde, erlaubt <code>dlsym</code> den Zugriff auf spezifische Funktionen oder
                    Variablen innerhalb dieser Bibliothek.</li>
                <li><strong>Parameter:</strong>
                    <ul>
                        <li><code>handle</code>: Ein Zeiger auf das Handle der geöffneten Bibliothek, das von
                            <code>dlopen</code> zurückgegeben wurde.
                        </li>
                        <li><code>symbol</code>: Ein Zeiger auf eine Zeichenkette, die den Namen des gesuchten Symbols
                            angibt.</li>
                    </ul>
                </li>
                <li><strong>Rückgabewert:</strong> <code>dlsym</code> gibt einen Zeiger auf das gefundene Symbol zurück.
                    Dieser Zeiger kann dann für den direkten Aufruf von Funktionen oder den Zugriff auf Variablen
                    verwendet werden. Wenn das Symbol nicht gefunden wird, gibt <code>dlsym</code> NULL zurück.</li>
                <li><strong>Verwendung:</strong>
                    <ul>
                        <li>Häufig verwendet in Szenarien, in denen Programmcode zur Laufzeit dynamisch geladen und
                            aufgerufen werden muss, basierend auf Benutzereingaben oder Konfigurationsdateien.</li>
                        <li>Ermöglicht es, Bibliotheken modular zu verwenden und nur die benötigten Teile zur Laufzeit
                            zu laden.</li>
                    </ul>
                </li>
            </ul>
            <a href="https://man7.org/linux/man-pages/man3/dlsym.3.html" target="_blank">Man-Page für dlsym</a>
            </p>

            <h3>dlclose</h3>
            <p>
                Die Funktion <code>dlclose</code> schließt eine zuvor mit <code>dlopen</code> geöffnete dynamische
                Bibliothek
                und gibt die damit verbundenen Ressourcen frei.
                <br>
                <a href="https://man7.org/linux/man-pages/man3/dlclose.3.html" target="_blank">Man-Page für dlclose</a>
            </p>
    </div>

    <!-- Ergänzter Abschnitt zum Unterschied zwischen statischen und dynamischen Bibliotheken -->
    <div class="importantBox">
        <h3>Zusammenfassung: Unterschied zwischen statischen und dynamischen Bibliotheken</h3>
        <ul>
            <li>Statische Bibliotheken werden zur Kompilierzeit in das ausführbare Programm eingebunden,
                während dynamische Bibliotheken zur Laufzeit geladen werden.</li>
            <li>Statische Bibliotheken erhöhen die Dateigröße des ausführbaren Programms,
                während dynamische Bibliotheken die Flexibilität und Wiederverwendbarkeit verbessern.</li>
            <li>Statische Bibliotheken benötigen keine externe Installation, während dynamische
                Bibliotheken von einer separaten DLL-Datei abhängen.</li>
            <li>Statische Bibliotheken sind besser für kleinere Anwendungen geeignet,
                während dynamische Bibliotheken häufig für große oder komplexe Softwareprojekte verwendet werden.</li>
        </ul>
    </div>
    <!-- Nützliche Links -->
    <div class="links">
        <h3>Nützliche Links</h3>
        <ul>
            <li><a href="https://de.wikipedia.org/wiki/Dynamic-Link-Library" target="_blank">Wikipedia: Dynamic Link
                    Library (DLL)</a></li>
            <li><a href="https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-creation"
                    target="_blank">Microsoft: Dynamic-Link Library (DLL) Creation</a></li>
        </ul>
    </div>
    <div id="grundlagen-2">
        <h2>Vorteile der DLL Nutzung zu Verbindung von Hardware Geräten mit Software</h2>

        <div>
            <h2>Grundlegend</h2>
            <ol>
                <li><strong>Abstraktion der Hardware:</strong> Durch die Implementierung der Gerätekommunikation
                    in einer DLL wird die Hardware von der Anwendungslogik entkoppelt. Dies ermöglicht eine klarere
                    Trennung der Verantwortlichkeiten und vereinfacht die Softwarearchitektur.</li>
                <li><strong>Modularität und Wiederverwendbarkeit:</strong> Die Gerätekommunikationsfunktionalität
                    kann in Form einer DLL als eigenständiges Modul entwickelt werden. Diese Modularität ermöglicht es,
                    die DLL in verschiedenen Projekten oder Anwendungen wiederzuverwenden, ohne den Kommunikationscode
                    jedes Mal neu schreiben zu müssen.</li>
                <li><strong>Flexibilität bei Updates und Erweiterungen:</strong> Änderungen oder Verbesserungen an der
                    Gerätekommunikation können einfach in der DLL implementiert und verteilt werden. Anwendungen, die
                    die DLL verwenden,
                    profitieren automatisch von diesen Updates, ohne dass sie neu kompiliert werden müssen.</li>
                <li><strong>Einfache Integration in verschiedene Plattformen:</strong> Da DLLs plattformübergreifend
                    verwendet werden können (vorausgesetzt,
                    die Abhängigkeiten sind bekannt und berücksichtigt), erleichtert dies die Integration der
                    Gerätekommunikation in Anwendungen, die auf verschiedenen Betriebssystemen laufen.</li>
                <li><strong>Fehlerisolation und -behandlung:</strong> Fehler, die während der Kommunikation mit dem
                    Hardwaregerät auftreten, können
                    innerhalb der DLL abgefangen und behandelt werden, ohne dass die Hauptanwendung beeinträchtigt wird.
                    Dies verbessert die Stabilität
                    und Zuverlässigkeit der Gesamtanwendung.</li>
                <li><strong>Optimierte Ressourcennutzung:</strong> Die DLL wird nur dann geladen und im Speicher
                    gehalten, wenn sie benötigt wird.
                    Dadurch wird der Speicherverbrauch der Hauptanwendung optimiert und Ressourcen effizient genutzt.
                </li>
            </ol>
        </div>

        <p>
            Insgesamt ermöglicht die Verwendung einer DLL für die Kommunikation mit einem Hardwaregerät eine saubere,
            modulare und flexible Architektur, die sowohl die Entwicklung als auch die Wartung von Software erleichtert
            und verbessert.
        </p>
        <div class="importantBox">
            <h2>Wichtigste Vorteile:</h2>
            <ul>
                <li>Abstraktion der Hardware</li>
                <li>Modularität und Wiederverwendbarkeit</li>
                <li>Flexibilität bei Updates und Erweiterungen</li>
                <li>Einfache Integration in verschiedene Plattformen</li>
                <li>Fehlerisolation und -behandlung</li>
                <li>Optimierte Ressourcennutzung</li>
            </ul>
        </div>
    </div>
    <div class="codebox">
        <h3> Pseudocode für den generellen Prozess zur Nutzung einer DLL um ein Hardwaregerät mit einer Software zu
            verbinden</h3>
        <h2> Initialisierung der DLL und Verbindung zum Hardwaregerät</h2>
        <pre><code>
            // Initialisierung der DLL
            dll_handle = load_library("hardware_communication.dll");
            
            // Überprüfen, ob die DLL erfolgreich geladen wurde
            if (dll_handle is not null) {
                // Funktion zum Initialisieren der Hardwarekommunikation aufrufen
                result = dll_initialize_hardware(dll_handle);
            
                // Überprüfen, ob die Initialisierung erfolgreich war
                if (result == success) {
                    // Hardware ist jetzt bereit für die Kommunikation
                    // Weitere Aktionen wie Konfiguration, Datenabruf usw.
                } else {
                    // Fehlerbehandlung bei der Initialisierung der Hardware
                    log_error("Fehler bei der Initialisierung der Hardware");
                }
            } else {
                // Fehlerbehandlung: DLL konnte nicht geladen werden
                log_error("Fehler beim Laden der DLL 'hardware_communication.dll'");
            }
            
        </code></pre>
        <button class="copy-button" onclick="copyToClipboard(1)">Kopieren</button>
        <span class="copy-message">Kopiert!</span>
        <h2>Senden und Empfangen der Daten</h2>
        <pre><code>
            // Daten an die Hardware senden
            send_data_to_hardware(dll_handle, data_to_send);
            
            // Auf Antwort von der Hardware warten und empfangene Daten verarbeiten
            received_data = receive_data_from_hardware(dll_handle);
            
            // Verarbeitung der empfangenen Daten
            process_received_data(received_data);            
        </code></pre>
        <button class="copy-button" onclick="copyToClipboard(1)">Kopieren</button>
        <span class="copy-message">Kopiert!</span>
        <h2>Aufräumen der Ressourcen</h2>
        <pre><code>
            // Freigabe der Ressourcen und Beenden der Kommunikation
                result = dll_cleanup_hardware(dll_handle);

                // Überprüfen, ob die Ressourcen erfolgreich freigegeben wurden
                if (result == success) {
             // Aufräumen war erfolgreich
            } else {
              // Fehlerbehandlung beim Aufräumen der Hardwarekommunikation
              log_error("Fehler beim Aufräumen der Hardwarekommunikation");
            }

            // DLL entladen
            unload_library(dll_handle);      
        </code></pre>
        <button class="copy-button" onclick="copyToClipboard(1)">Kopieren</button>
        <span class="copy-message">Kopiert!</span>
    </div>

    </div>
    </div>

    <!-- Section: DLL-Entwicklung -->
    <div id="entwicklung" class="section">
        <div id="entwicklung-1">
            <h3>DLL-Entwicklung</h3>
            <p>Bestimme, in welcher Programmiersprache du die DLL entwickeln möchtest (z.B. C++, C#, etc.).</p>
            <h2>Programmiersprachen für die Entwicklung von DLLs zur Hardwarekommunikation</h2>
            <p>Es gibt mehrere Programmiersprachen, die sich gut für die Entwicklung einer DLL eignen, die grundlegende
                Kommunikation mit einem Hardwaregerät mit hoher Datenübertragungsrate implementieren soll. Die Wahl der
                Programmiersprache hängt von verschiedenen Faktoren ab, darunter die Plattform des Hardwaregeräts, die
                Art der Schnittstelle (z.B. USB, Ethernet) und die Präferenzen des Entwicklers oder des
                Entwicklungsteams. Hier sind einige häufig verwendete Programmiersprachen, die für diese Art von
                Aufgaben gut geeignet sind:</p>
            <ul>
                <li><strong>C/C++:</strong> C und C++ sind besonders gut geeignet, wenn es um die Entwicklung von DLLs
                    für die Hardwarekommunikation geht. Sie bieten eine direkte Kontrolle über Hardware-Ressourcen und
                    eine effiziente Speicherverwaltung, was für Anwendungen mit hoher Datenübertragungsrate wichtig ist.
                    C/C++ wird oft verwendet, um Treiber und Schnittstellen für Hardwaregeräte zu entwickeln, da sie
                    nahe an der Hardware operieren können.</li>
                <li><strong>C#:</strong> Für Windows-Plattformen ist C# eine ausgezeichnete Wahl, insbesondere wenn die
                    Anwendung eine hohe Integration mit dem .NET Framework erfordert. C# ermöglicht es, schnell robuste
                    und sichere Anwendungen zu entwickeln und bietet eine gute Unterstützung für die Interaktion mit
                    externen DLLs.</li>
                <li><strong>Python:</strong> Python ist eine beliebte Wahl für die Entwicklung von Anwendungen, die mit
                    Hardwaregeräten kommunizieren müssen, insbesondere in Verbindung mit Bibliotheken wie ctypes oder
                    CFFI, die die Integration mit nativen DLLs erleichtern. Python ist für seine einfache Syntax und
                    große Entwicklergemeinschaft bekannt.</li>
                <li><strong>Java:</strong> Obwohl Java in der Regel für plattformübergreifende Anwendungen bevorzugt
                    wird, kann es auch für die Entwicklung von DLLs verwendet werden, insbesondere wenn die
                    Hardwarekommunikation über eine Java Native Interface (JNI) oder spezielle Java-Bibliotheken
                    erfolgen soll.</li>
                <li><strong>Rust:</strong> Rust ist eine moderne Programmiersprache, die Sicherheit und Geschwindigkeit
                    kombiniert und gut für die Entwicklung von Systemsoftware geeignet ist. Rust kann verwendet werden,
                    um leistungsstarke DLLs zu erstellen, die effizient mit Hardwaregeräten kommunizieren können.</li>
            </ul>
            <p>Die Wahl der Programmiersprache hängt auch von anderen Faktoren wie der vorhandenen Expertise im Team,
                der Plattformunterstützung und den spezifischen Anforderungen des Projekts ab. Für Aufgaben, die eine
                hohe Datenübertragungsrate erfordern, sind C/C++ aufgrund ihrer Leistung und Kontrolle über die
                Ressourcen oft die bevorzugte Wahl.</p>
        </div>
        <div class="importantBox">
            Für dieses Projekt wird C++, auf grund seiner Leistung und Kontrolle, gewählt.
        </div>
        <div class="nebeninfo">
            <h2> Kurze Definition einer Callback funktion</h2>
            Eine Callback-Funktion ist eine Funktion in JavaScript, die als Argument an eine andere Funktion übergeben
            wird und später zurückgerufen wird, sobald eine bestimmte Operation abgeschlossen ist. Sie ermöglicht es,
            asynchrone Operationen zu verarbeiten, ohne den Hauptprogrammfluss zu blockieren, und bietet eine flexible
            Möglichkeit, auf das Ergebnis einer Operation zu reagieren. Callback-Funktionen sind besonders nützlich für
            Ereignisbehandlung, Datenverarbeitung und die Koordination paralleler Abläufe in JavaScript-Anwendungen.
        </div>

        <div id="entwicklung-2">


        </div>
        <div class="codebox">
            <h3>Pseudocode für eine einfache Hardware Kommunikations DLL in C++</h3>
            <pre><code>
                // Pseudocode für die DLL 'hardware_communication.dll'

                // Struktur oder globale Variablen für die Kommunikation
                var hardware_connection = null;
                
            </code></pre>
            <button class="copy-button" onclick="copyToClipboard(1)">Kopieren</button>
            <span class="copy-message">Kopiert!</span>
            <h2> Initialisierung der Hardwarekommunikation</h2>
            <pre><code>
                function dll_initialize_hardware() {
                    // Verbindung zur Hardware herstellen
                    hardware_connection = connect_to_hardware();
                
                    // Überprüfen, ob die Verbindung erfolgreich hergestellt wurde
                    if (hardware_connection is not null) {
                        return success; // Initialisierung erfolgreich
                    } else {
                        return failure; // Fehler bei der Initialisierung
                    }
                }
            </code></pre>
            <button class="copy-button" onclick="copyToClipboard(1)">Kopieren</button>
            <span class="copy-message">Kopiert!</span>
            <h2>Senden von Daten an die Hardware</h2>
            <pre><code>
            function send_data_to_hardware(data_to_send) {
            if (hardware_connection is not null) {
            send_data(hardware_connection, data_to_send);
            } else {
            log_error("Verbindung zur Hardware nicht hergestellt");
            }
            }
            </code></pre>
            <button class="copy-button" onclick="copyToClipboard(1)">Kopieren</button>
            <span class="copy-message">Kopiert!</span>
            <h2>Empfangen von Daten der Hardware</h2>
            <pre><code>
            function receive_data_from_hardware() {
            var received_data = null;
            if (hardware_connection is not null) {
            received_data = receive_data(hardware_connection);
            } else {
            log_error("Verbindung zur Hardware nicht hergestellt");
            }
            return received_data;
            }
             </code></pre>
            <button class="copy-button" onclick="copyToClipboard(1)">Kopieren</button>
            <span class="copy-message">Kopiert!</span>
            <h2>Aufräumen der Ressourcen und Beenden der Kommunikation</h2>
            <pre><code>
            function dll_cleanup_hardware() {
            if (hardware_connection is not null) {
            close_connection(hardware_connection);
            hardware_connection = null;
            return success; // Aufräumen erfolgreich
            } else {
            return failure; // Fehler beim Aufräumen
            }
            }
            </code></pre>
            <button class="copy-button" onclick="copyToClipboard(1)">Kopieren</button>
            <span class="copy-message">Kopiert!</span>
        </div>
        <div class="importantBox">
            Dies ist nur erstmal Pseudocode alle tatsächlichen Kommunikationsfunktionen müssen nochmals implementiert
            werden.
            Funktionen wie send_data(), receive_data() etc. sind hier absichtlich offen gelassen um das Beispiel
            möglichst generisch zu halten.
        </div>
    </div>

    <!-- Section: Integration mit Hardware -->
    <div id="integration" class="section">
        <div class="infobox">
            <h3>Integration mit Hardware</h3>
            <p>Untersuche die spezifischen Datenübertragungsprotokolle, die dein Hardwaregerät verwendet.</p>
        </div>
        <div class="codebox">
            <h3>Beispielcode für Hardwareintegration</h3>
            <pre><code>// Beispielcode für Hardwareintegration mit DLL
#include &lt;windows.h&gt;
#include &lt;iostream&gt;

extern "C" __declspec(dllexport) void ControlDevice(int command)
{
    // Code zur Steuerung des Hardwaregeräts
    std::cout &lt;&lt; "Device command received: " &lt;&lt; command &lt;&lt; std::endl;
}</code></pre>
        </div>
    </div>

    <!-- Section: Sicherheit und Stabilität -->
    <div id="sicherheit" class="section">
        <div class="infobox">
            <h3>Sicherheit und Stabilität</h3>
            <p>Implementiere Mechanismen zur Fehlererkennung und Fehlerbehandlung in der DLL.</p>
        </div>
        <div class="codebox">
            <h3>Beispielcode für Fehlerbehandlung</h3>
            <pre><code>// Beispielcode für Fehlerbehandlung in DLL
#include &lt;windows.h&gt;

extern "C" __declspec(dllexport) void HandleErrors()
{
    // Code zur Fehlerbehandlung in der DLL
    try {
        // Hier Fehlerhandling-Logik einfügen
    } catch (...) {
        // Fehlerbehandlung bei Ausnahmen
    }
}</code></pre>
        </div>
    </div>

    <!-- Section: Dokumentation und Wartung -->
    <div id="dokumentation" class="section">
        <div class="infobox">
            <h3>Dokumentation und Wartung</h3>
            <p>Erstelle eine klare Dokumentation für die DLL, einschließlich der Schnittstellenbeschreibung und der
                Nutzungshinweise für andere Entwickler.</p>
        </div>
        <div class="codebox">
            <h3>Beispielcode für DLL-Dokumentation</h3>
            <pre><code>// Beispielcode für DLL-Dokumentation
// API-Schnittstellenbeschreibung
/**
 * @brief Funktion zur Berechnung der Fläche eines Rechtecks.
 * 
 * Berechnet die Fläche eines Rechtecks basierend auf der gegebenen Breite und Höhe.
 * 
 * @param width Die Breite des Rechtecks.
 * @param height Die Höhe des Rechtecks.
 * @return Die berechnete Fläche des Rechtecks.
 */
extern "C" __declspec(dllexport) double CalculateRectangleArea(double width, double height);
</code></pre>
        </div>
    </div>

    <script src="script.js"></script>
</body>

</html>